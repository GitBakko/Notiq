// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  name      String?
  surname   String?
  gender    String?
  dateOfBirth DateTime?
  placeOfBirth String?
  mobile    String?
  avatarUrl String?
  color     String?
  resetToken String?
  resetTokenExpiry DateTime?
  locale    String   @default("en")
  createdAt DateTime @default(now())
  lastActiveAt DateTime @default(now())
  
  notebooks Notebook[]
  notes     Note[]
  tags      Tag[]
  sharedNotes     SharedNote[]
  sharedNotebooks SharedNotebook[]
  notifications   Notification[]
  pushSubscriptions PushSubscription[]
  chatMessages    ChatMessage[]
  aiConversations AiConversation[]
  auditLogs       AuditLog[]
  
  // Auth & Invites
  role            Role     @default(USER)
  isVerified      Boolean  @default(false)
  verificationToken String?
  verificationTokenExpires DateTime?
  invitationCode  String? // The code they used to register
  invitesAvailable Int     @default(2)
  tokenVersion     Int     @default(0)

  createdInvitations Invitation[] @relation("CreatedInvitations")
  usedInvitation     Invitation?  @relation("UsedInvitation")

  ownedGroups      Group[]       @relation("OwnedGroups")
  groupMemberships GroupMember[] @relation("GroupMemberships")

  taskLists        TaskList[]
  sharedTaskLists  SharedTaskList[]
}

enum Role {
  USER
  SUPERADMIN
}

model Invitation {
  id        String   @id @default(uuid())
  code      String   @unique
  creatorId String
  creator   User     @relation("CreatedInvitations", fields: [creatorId], references: [id])
  usedById  String?  @unique
  usedBy    User?    @relation("UsedInvitation", fields: [usedById], references: [id])
  createdAt DateTime @default(now())
  usedAt    DateTime?
  status    InvitationStatus @default(PENDING)
}

enum InvitationStatus {
  PENDING
  USED
}

model SystemSetting {
  key         String  @id
  value       String
  description String?
}

model Notebook {
  id        String   @id @default(uuid())
  name      String
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  notes     Note[]
  sharedWith SharedNotebook[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Note {
  id          String   @id @default(uuid())
  title       String
  content     String   // HTML/JSON content
  searchText  String?  // Plain text for search
  notebookId  String
  notebook    Notebook @relation(fields: [notebookId], references: [id])
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  tags        TagsOnNotes[]
  attachments Attachment[]
  sharedWith  SharedNote[]
  chatMessages ChatMessage[]
  aiConversations AiConversation[]
  isTrashed   Boolean  @default(false)
  reminderDate DateTime?
  isReminderDone Boolean @default(false)
  isPublic    Boolean  @default(false)
  shareId     String?  @unique
  isPinned    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  isVault     Boolean  @default(false)
  isEncrypted Boolean  @default(false)
  noteType    NoteType @default(NOTE)
  ydocState   Bytes?   // Yjs binary state for CRDT-safe collaboration
  searchVector Unsupported("tsvector")?

  @@index([userId, isTrashed])
  @@index([notebookId])
}

model Tag {
  id     String   @id @default(uuid())
  name   String
  userId String
  user   User     @relation(fields: [userId], references: [id])
  notes  TagsOnNotes[]
  
  isVault Boolean @default(false)
  
  @@unique([userId, name, isVault])
}

model TagsOnNotes {
  noteId String
  tagId  String
  note   Note @relation(fields: [noteId], references: [id], onDelete: Cascade)
  tag    Tag  @relation(fields: [tagId], references: [id])

  @@id([noteId, tagId])
}

model Attachment {
  id        String   @id @default(uuid())
  noteId    String
  note      Note     @relation(fields: [noteId], references: [id], onDelete: Cascade)
  url       String
  filename  String
  mimeType  String
  size      Int
  createdAt DateTime @default(now())

  version   Int      @default(1)
  hash      String?
  isLatest  Boolean  @default(true)

  @@index([noteId, isLatest])
}

enum NoteType {
  NOTE
  CREDENTIAL
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
}

enum Permission {
  READ
  WRITE
}

model SharedNote {
  id         String     @id @default(uuid())
  noteId     String
  note       Note       @relation(fields: [noteId], references: [id], onDelete: Cascade)
  userId     String
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission Permission @default(READ)
  status     ShareStatus @default(PENDING)
  createdAt  DateTime   @default(now())

  @@unique([noteId, userId])
  @@index([userId, status])
}

model SharedNotebook {
  id         String     @id @default(uuid())
  notebookId String
  notebook   Notebook   @relation(fields: [notebookId], references: [id], onDelete: Cascade)
  userId     String
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission Permission @default(READ)
  status     ShareStatus @default(PENDING)
  createdAt  DateTime   @default(now())

  @@unique([notebookId, userId])
  @@index([userId, status])
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  message   String
  data      Json?
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId, isRead])
}

enum NotificationType {
  SHARE_NOTE
  SHARE_NOTEBOOK
  SYSTEM
  REMINDER
  CHAT_MESSAGE
  GROUP_INVITE
  GROUP_REMOVE
  TASK_ITEM_ADDED
  TASK_ITEM_CHECKED
  TASK_ITEM_REMOVED
  TASK_LIST_SHARED
}

model PushSubscription {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  endpoint  String
  keys      Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ChatMessage {
  id        String   @id @default(uuid())
  noteId    String
  note      Note     @relation(fields: [noteId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  content   String
  createdAt DateTime @default(now())

  @@index([noteId])
}

enum ShareStatus {
  PENDING
  ACCEPTED
  DECLINED
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  event     String
  details   Json?
  createdAt DateTime @default(now())

  @@index([userId])
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
}

model InvitationRequest {
  id        String   @id @default(uuid())
  email     String   @unique
  status    RequestStatus @default(PENDING)
  ipAddress String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AiConversation {
  id        String   @id @default(uuid())
  noteId    String
  note      Note     @relation(fields: [noteId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role      String   // "user" | "assistant"
  content   String
  operation String?  // "ask" | "summarize" | "continue" | "improve" | "tags" | "translate"
  metadata  Json?
  createdAt DateTime @default(now())
}

model Group {
  id             String               @id @default(uuid())
  name           String
  description    String?
  avatarUrl      String?
  ownerId        String
  owner          User                 @relation("OwnedGroups", fields: [ownerId], references: [id], onDelete: Cascade)
  members        GroupMember[]
  pendingInvites PendingGroupInvite[]
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
}

model GroupMember {
  groupId  String
  group    Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  userId   String
  user     User     @relation("GroupMemberships", fields: [userId], references: [id], onDelete: Cascade)
  joinedAt DateTime @default(now())

  @@id([groupId, userId])
}

model PendingGroupInvite {
  id        String   @id @default(uuid())
  groupId   String
  group     Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  email     String
  invitedBy String
  createdAt DateTime @default(now())

  @@unique([groupId, email])
}

model TaskList {
  id          String           @id @default(uuid())
  title       String
  userId      String
  user        User             @relation(fields: [userId], references: [id])
  items       TaskItem[]
  sharedWith  SharedTaskList[]
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  isTrashed   Boolean          @default(false)

  @@index([userId, isTrashed])
}

model TaskItem {
  id          String        @id @default(uuid())
  taskListId  String
  taskList    TaskList      @relation(fields: [taskListId], references: [id], onDelete: Cascade)
  text        String
  isChecked   Boolean       @default(false)
  priority    TaskPriority  @default(MEDIUM)
  dueDate     DateTime?
  position    Int           @default(0)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([taskListId])
}

model SharedTaskList {
  id          String      @id @default(uuid())
  taskListId  String
  taskList    TaskList    @relation(fields: [taskListId], references: [id], onDelete: Cascade)
  userId      String
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission  Permission  @default(READ)
  status      ShareStatus @default(PENDING)
  createdAt   DateTime    @default(now())

  @@unique([taskListId, userId])
  @@index([userId, status])
}
