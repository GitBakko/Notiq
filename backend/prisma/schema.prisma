// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  name      String?
  surname   String?
  gender    String?
  dateOfBirth DateTime?
  placeOfBirth String?
  mobile    String?
  avatarUrl String?
  color     String?
  resetToken String?
  resetTokenExpiry DateTime?
  locale    String   @default("en")
  emailNotificationsEnabled Boolean @default(true)
  createdAt DateTime @default(now())
  lastActiveAt DateTime @default(now())
  
  notebooks Notebook[]
  notes     Note[]
  tags      Tag[]
  sharedNotes     SharedNote[]
  sharedNotebooks SharedNotebook[]
  notifications   Notification[]
  pushSubscriptions PushSubscription[]
  chatMessages    ChatMessage[]
  aiConversations AiConversation[]
  auditLogs       AuditLog[]
  
  // Auth & Invites
  role            Role     @default(USER)
  isVerified      Boolean  @default(false)
  verificationToken String?
  verificationTokenExpires DateTime?
  invitationCode  String? // The code they used to register
  invitesAvailable Int     @default(2)
  tokenVersion     Int     @default(0)

  createdInvitations Invitation[] @relation("CreatedInvitations")
  usedInvitation     Invitation?  @relation("UsedInvitation")

  ownedGroups      Group[]       @relation("OwnedGroups")
  groupMemberships GroupMember[] @relation("GroupMemberships")

  taskLists        TaskList[]
  sharedTaskLists  SharedTaskList[]
  checkedTaskItems TaskItem[]     @relation("CheckedTaskItems")

  // Kanban
  kanbanBoards         KanbanBoard[]       @relation("KanbanOwner")
  kanbanAssignedCards  KanbanCard[]        @relation("KanbanAssignee")
  kanbanComments       KanbanComment[]     @relation("KanbanCommentAuthor")
  sharedKanbanBoards   SharedKanbanBoard[] @relation("KanbanBoardShares")
  kanbanBoardChats     KanbanBoardChat[]   @relation("KanbanBoardChatAuthor")
  kanbanCardActivities KanbanCardActivity[] @relation("KanbanActivityUser")
  kanbanLinkedCards     KanbanCard[]         @relation("KanbanNoteLinker")
  kanbanLinkedBoards   KanbanBoard[]        @relation("KanbanBoardNoteLinker")
  kanbanReminders      KanbanReminder[]     @relation("KanbanReminderUser")
  kanbanBoardTaskListLinks KanbanBoard[]    @relation("KanbanBoardTaskListLinker")
}

enum Role {
  USER
  SUPERADMIN
}

model Invitation {
  id        String   @id @default(uuid())
  code      String   @unique
  creatorId String
  creator   User     @relation("CreatedInvitations", fields: [creatorId], references: [id])
  usedById  String?  @unique
  usedBy    User?    @relation("UsedInvitation", fields: [usedById], references: [id])
  createdAt DateTime @default(now())
  usedAt    DateTime?
  status    InvitationStatus @default(PENDING)
}

enum InvitationStatus {
  PENDING
  USED
}

model SystemSetting {
  key         String  @id
  value       String
  description String?
}

model Notebook {
  id        String   @id @default(uuid())
  name      String
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  notes     Note[]
  sharedWith SharedNotebook[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Note {
  id          String   @id @default(uuid())
  title       String
  content     String   // HTML/JSON content
  searchText  String?  // Plain text for search
  notebookId  String
  notebook    Notebook @relation(fields: [notebookId], references: [id])
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  tags        TagsOnNotes[]
  attachments Attachment[]
  sharedWith  SharedNote[]
  chatMessages ChatMessage[]
  aiConversations AiConversation[]
  isTrashed   Boolean  @default(false)
  reminderDate DateTime?
  isReminderDone Boolean @default(false)
  isPublic    Boolean  @default(false)
  shareId     String?  @unique
  isPinned    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  isVault     Boolean  @default(false)
  isEncrypted Boolean  @default(false)
  noteType    NoteType @default(NOTE)
  ydocState   Bytes?   // Yjs binary state for CRDT-safe collaboration
  searchVector Unsupported("tsvector")?

  kanbanCards   KanbanCard[]
  kanbanBoards  KanbanBoard[] @relation("KanbanBoardNote")

  @@index([userId, isTrashed])
  @@index([notebookId])
}

model Tag {
  id     String   @id @default(uuid())
  name   String
  userId String
  user   User     @relation(fields: [userId], references: [id])
  notes  TagsOnNotes[]
  
  isVault Boolean @default(false)
  
  @@unique([userId, name, isVault])
}

model TagsOnNotes {
  noteId String
  tagId  String
  note   Note @relation(fields: [noteId], references: [id], onDelete: Cascade)
  tag    Tag  @relation(fields: [tagId], references: [id])

  @@id([noteId, tagId])
}

model Attachment {
  id        String   @id @default(uuid())
  noteId    String
  note      Note     @relation(fields: [noteId], references: [id], onDelete: Cascade)
  url       String
  filename  String
  mimeType  String
  size      Int
  createdAt DateTime @default(now())

  version   Int      @default(1)
  hash      String?
  isLatest  Boolean  @default(true)

  @@index([noteId, isLatest])
}

enum NoteType {
  NOTE
  CREDENTIAL
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
}

enum Permission {
  READ
  WRITE
}

model SharedNote {
  id         String     @id @default(uuid())
  noteId     String
  note       Note       @relation(fields: [noteId], references: [id], onDelete: Cascade)
  userId     String
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission Permission @default(READ)
  status     ShareStatus @default(PENDING)
  createdAt  DateTime   @default(now())

  @@unique([noteId, userId])
  @@index([userId, status])
}

model SharedNotebook {
  id         String     @id @default(uuid())
  notebookId String
  notebook   Notebook   @relation(fields: [notebookId], references: [id], onDelete: Cascade)
  userId     String
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission Permission @default(READ)
  status     ShareStatus @default(PENDING)
  createdAt  DateTime   @default(now())

  @@unique([notebookId, userId])
  @@index([userId, status])
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  message   String
  data      Json?
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId, isRead])
}

enum NotificationType {
  SHARE_NOTE
  SHARE_NOTEBOOK
  SYSTEM
  REMINDER
  CHAT_MESSAGE
  GROUP_INVITE
  GROUP_REMOVE
  TASK_ITEM_ADDED
  TASK_ITEM_CHECKED
  TASK_ITEM_REMOVED
  TASK_LIST_SHARED
  KANBAN_BOARD_SHARED
  KANBAN_CARD_ASSIGNED
  KANBAN_COMMENT_ADDED
  KANBAN_CARD_MOVED
  KANBAN_COMMENT_DELETED
}

model PushSubscription {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  endpoint  String
  keys      Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Note-level chat. Intentionally separate from KanbanBoardChat despite
// similar structure: different parent entity (Note vs Board), different
// notification logic (Hocuspocus presence vs SSE), different access patterns.
// Unifying would require nullable FKs or polymorphic pattern, losing
// referential integrity for no practical benefit.
model ChatMessage {
  id        String   @id @default(uuid())
  noteId    String
  note      Note     @relation(fields: [noteId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  content   String
  createdAt DateTime @default(now())

  @@index([noteId])
}

enum ShareStatus {
  PENDING
  ACCEPTED
  DECLINED
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  event     String
  details   Json?
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
}

model InvitationRequest {
  id        String   @id @default(uuid())
  email     String   @unique
  status    RequestStatus @default(PENDING)
  ipAddress String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AiConversation {
  id        String   @id @default(uuid())
  noteId    String
  note      Note     @relation(fields: [noteId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role      String   // "user" | "assistant"
  content   String
  operation String?  // "ask" | "summarize" | "continue" | "improve" | "tags" | "translate"
  metadata  Json?
  createdAt DateTime @default(now())
}

model Group {
  id             String               @id @default(uuid())
  name           String
  description    String?
  avatarUrl      String?
  ownerId        String
  owner          User                 @relation("OwnedGroups", fields: [ownerId], references: [id], onDelete: Cascade)
  members        GroupMember[]
  pendingInvites PendingGroupInvite[]
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
}

model GroupMember {
  groupId  String
  group    Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  userId   String
  user     User     @relation("GroupMemberships", fields: [userId], references: [id], onDelete: Cascade)
  joinedAt DateTime @default(now())

  @@id([groupId, userId])
  @@index([userId])
}

model PendingGroupInvite {
  id        String   @id @default(uuid())
  groupId   String
  group     Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  email     String
  invitedBy String
  createdAt DateTime @default(now())

  @@unique([groupId, email])
}

model TaskList {
  id          String           @id @default(uuid())
  title       String
  userId      String
  user        User             @relation(fields: [userId], references: [id])
  items       TaskItem[]
  sharedWith  SharedTaskList[]
  kanbanBoard KanbanBoard?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  isTrashed   Boolean          @default(false)

  @@index([userId, isTrashed])
}

model TaskItem {
  id              String        @id @default(uuid())
  taskListId      String
  taskList        TaskList      @relation(fields: [taskListId], references: [id], onDelete: Cascade)
  text            String
  isChecked       Boolean       @default(false)
  checkedByUserId String?
  checkedByUser   User?         @relation("CheckedTaskItems", fields: [checkedByUserId], references: [id], onDelete: SetNull)
  priority        TaskPriority  @default(MEDIUM)
  dueDate         DateTime?
  position        Int           @default(0)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  kanbanCard      KanbanCard?

  @@index([taskListId])
}

model SharedTaskList {
  id          String      @id @default(uuid())
  taskListId  String
  taskList    TaskList    @relation(fields: [taskListId], references: [id], onDelete: Cascade)
  userId      String
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission  Permission  @default(READ)
  status      ShareStatus @default(PENDING)
  createdAt   DateTime    @default(now())

  @@unique([taskListId, userId])
  @@index([userId, status])
}

// ─── Kanban ──────────────────────────────────────────────────

model KanbanBoard {
  id              String              @id @default(uuid())
  title           String
  description     String?
  coverImage      String?
  avatarUrl       String?
  noteId          String?
  note            Note?               @relation("KanbanBoardNote", fields: [noteId], references: [id])
  noteLinkedById  String?
  noteLinkedBy    User?               @relation("KanbanBoardNoteLinker", fields: [noteLinkedById], references: [id])
  taskListId         String?          @unique
  taskList           TaskList?        @relation(fields: [taskListId], references: [id])
  taskListLinkedById String?
  taskListLinkedBy   User?            @relation("KanbanBoardTaskListLinker", fields: [taskListLinkedById], references: [id])
  ownerId         String
  owner           User                @relation("KanbanOwner", fields: [ownerId], references: [id])
  columns         KanbanColumn[]
  shares          SharedKanbanBoard[]
  chatMessages    KanbanBoardChat[]
  reminders       KanbanReminder[]
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@index([ownerId])
  @@index([noteId])
}

model KanbanColumn {
  id          String       @id @default(uuid())
  title       String
  position    Int
  isCompleted Boolean      @default(false)
  boardId     String
  board       KanbanBoard  @relation(fields: [boardId], references: [id], onDelete: Cascade)
  cards       KanbanCard[]

  @@index([boardId])
}

model KanbanCard {
  id          String          @id @default(uuid())
  title       String
  description String?
  position    Int
  columnId    String
  column      KanbanColumn    @relation(fields: [columnId], references: [id], onDelete: Cascade)
  assigneeId  String?
  assignee    User?           @relation("KanbanAssignee", fields: [assigneeId], references: [id])
  dueDate     DateTime?
  priority    KanbanCardPriority?
  archivedAt  DateTime?
  taskItemId  String?         @unique
  taskItem    TaskItem?       @relation(fields: [taskItemId], references: [id], onDelete: SetNull)
  noteId          String?
  note            Note?           @relation(fields: [noteId], references: [id])
  noteLinkedById  String?
  noteLinkedBy    User?           @relation("KanbanNoteLinker", fields: [noteLinkedById], references: [id])
  comments        KanbanComment[]
  activities      KanbanCardActivity[]
  reminders       KanbanReminder[]
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@index([columnId])
  @@index([assigneeId])
  @@index([noteId])
}

model KanbanComment {
  id        String     @id @default(uuid())
  content   String
  cardId    String
  card      KanbanCard @relation(fields: [cardId], references: [id], onDelete: Cascade)
  authorId  String
  author    User       @relation("KanbanCommentAuthor", fields: [authorId], references: [id])
  createdAt DateTime   @default(now())

  @@index([cardId])
}

model SharedKanbanBoard {
  id         String      @id @default(uuid())
  boardId    String
  board      KanbanBoard @relation(fields: [boardId], references: [id], onDelete: Cascade)
  userId     String
  user       User        @relation("KanbanBoardShares", fields: [userId], references: [id], onDelete: Cascade)
  permission Permission  @default(READ)
  status     ShareStatus @default(PENDING)
  createdAt  DateTime    @default(now())

  @@unique([boardId, userId])
  @@index([userId, status])
}

// Board-level chat. See ChatMessage comment for why these are separate.
model KanbanBoardChat {
  id        String      @id @default(uuid())
  boardId   String
  board     KanbanBoard @relation(fields: [boardId], references: [id], onDelete: Cascade)
  authorId  String
  author    User        @relation("KanbanBoardChatAuthor", fields: [authorId], references: [id])
  content   String
  createdAt DateTime    @default(now())

  @@index([boardId, createdAt])
  @@index([authorId])
}

enum KanbanCardPriority {
  STANDBY
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum KanbanCardAction {
  CREATED
  MOVED
  UPDATED
  ASSIGNED
  UNASSIGNED
  DUE_DATE_SET
  DUE_DATE_REMOVED
  NOTE_LINKED
  NOTE_UNLINKED
  DELETED
}

model KanbanCardActivity {
  id             String           @id @default(uuid())
  cardId         String
  card           KanbanCard       @relation(fields: [cardId], references: [id], onDelete: Cascade)
  userId         String
  user           User             @relation("KanbanActivityUser", fields: [userId], references: [id])
  action         KanbanCardAction
  fromColumnTitle String?
  toColumnTitle   String?
  metadata       Json?
  createdAt      DateTime         @default(now())

  @@index([cardId, createdAt])
}

model KanbanReminder {
  id        String      @id @default(uuid())
  cardId    String
  card      KanbanCard  @relation(fields: [cardId], references: [id], onDelete: Cascade)
  userId    String
  user      User        @relation("KanbanReminderUser", fields: [userId], references: [id], onDelete: Cascade)
  boardId   String
  board     KanbanBoard @relation(fields: [boardId], references: [id], onDelete: Cascade)
  dueDate   DateTime
  isDone    Boolean     @default(false)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@unique([cardId, userId])
  @@index([userId, isDone])
  @@index([boardId])
}
